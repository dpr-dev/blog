- <b style="color: blue">#temporal</b>
- <b style="color: blue">#distributed_transactions</b>
- <b style="color: blue">#orchestration</b>

# Temporal: Введение. Часть 2: workflow versioning

В этой статье мы продолжим говорить о Temporal, а именно о том, какие подходы существуют для версионирования temporal workflow (ваших написанных процессов).

Она является продолжением цикла статей о temporal и нашем опыте работы с ним. Предыдущие статьи можно найти тут

- [Temporal: Введение. Часть 1](https://dpr-dev.github.io/blog/#/2024-11/01-temporal-intro-part-1)
- [Temporal: Введение. Часть 2: workflow versioning (эта статья)](https://dpr-dev.github.io/blog/#/2025-01/01-temporal-intro-part-2-versioning)

## Workflow versioning: в чем проблема ?

Перед тем, как обсуждать различные подходы к версионированию workflow, хочется немного поговорить о том, откуда вообще возникают проблемы, связанные с версионированием.

В первой статье я писал, что temporal сохраняет состояние всех шагов в базу данных. С одной стороны, это очень хороший подход, поскольку позволяет нам не бояться сбоев или падений и сделать наши workflow восстанавливаемыми. С другой стороны, в этом скрыта суть проблемы: temporal, в случае востановления workflow, проходит весь код по шагам, заново проигрывая все activity / timers, и сравнивает их с существующими сохраненными результатами в базе данных. Если он видит несоответствие между исполняемым кодом и сохраненным состоянием, workflow просто намертво замирает и единственный вариант с ним что-то сделать - убить (либо откатить код к предыдущей версии и передеплоить через history reset на несколько шагов назад, но это не всегда возможно, т.к. очень сильно зависит от того, как другие сервисы реагируют на повторный вызов той же ручки).

Очевидно, что в любом более-менее серьезном production с такими проблемами жить нельзя, поэтому нам нужно думать о том, как поставлять обновленные workflow без поломки обратной совместимости. К счастью, temporal предлагает некоторые варианты, которые позволяют сделать обратно-совместимую раскату всех процессов. Однако, иногда это требует немного больше работы, чем хотелось бы, причем не только на стороне temporal.

## Workflow versioning: основы

Temporal предоставляет нам возможность использовать различные подходы к версионированию, которые имеют свои преимущества и недостатки. Например

- **patched api** - подход, использующий концепцию `feature flags`
- **версионирование с помощью task queue** - один из самых простых подходов, в котором мы заводим новые очереди задач для измененных процессов (payments::v1, payments::v2, etc)
- **версионирование воркеров** -подход разработан на замену task queue версионированию, однако, он всё ещё в `pre-release`
- **дублирование workflow** - ещё один довольно простой подход, в котором мы просто дублируем код воркфлоу и изменяем его название (ProcessPayment vs ProcessPaymentV2)

К сожалению, во всех подходах есть свои pros & cons, поэтому я не могу назвать какое-то универсальное решение на все случаи жизни. Подход к версионированию нужно выбирать каждый раз, когда вы вносите изменения в workflow. И во многом, эти изменения и их "разрушительность" будут определять ваш выбор.

Помимо этого, довольно часто будут возникать ситуации, когда версионирования кода workflow будет недостаточно. Так как workflow почти всегда взаимодействуют с нашей системой (или системами) и на каждом этапе выполнения что-то в ней изменяет, довольно часто возникает ситуация, когда версионировать придется ещё и сами системы.

Тут хочу отметить, что взаимодействие может быть двунаправленным: как temporal workflow может обращаться к системе и что-то изменять в ней, так и система может обращаться к temporal и посылать в него сигналы или команды для обновления состояния.

### Workflow versioning: workflow duplication

В целом, один из самых простых способов. Может работать, если workflow небольшие и изолированные (не вызываются из других workflow). Если у вас нет ситуации, когда изменяемый workflow используется напрямую в каких-либо других workflow или ожидает получения каких-либо сигналов, то это один из самых простых способов внести какие-либо изменения в логику процесса.

В таком случае, вспоминая подход к запуску workflow из первой статьи, мы можем сделать довольно простое переключение сразу в логике контроллера.

Да, могут оставаться другие процессы, которые всё ещё работают, но рано или поздно они завершатся. Единственное, что от нас требуется - убедиться, что мы не изменили (или оставили обратно-совместимым) код самих сервисов, которые могут вызываться из activity этого workflow.

> [!WARNING]  
> Стоит быть осторожными при использовании подобного подхода: поскольку мы не изменяем task queue, выполнение acitivty никак не разделяется по очередям задач, поэтому изменение существующих activity может поломать существующие workflow v1. К сожалению, довольно часто придется дублировать и их (если мы захотим изменить их внутреннюю логику).

<details>
  <summary>Пример миграции на новую версию workflow</summary>

Ниже приведен код из первой статьи о temporal. В данном случае, мы просто заменяем версию workflow в коде и начинаем запускать её вместо старого v1 workflow.

```cs
[HttpPost("system.clients.startUserGrantedWorkflow")]
public async Task<IActionResult> StartUserGrantedWorkflow([FromBody] StartUserGrantedWorkflowRequest request)
{
  // код вырезан для простоты

  WorkflowOptions options = new()
  {
      Id = workflowId,
      RequestEagerStart = true,
      TaskQueue = TemporalTaskQueues.Clients
  };

  UserGrantedWorkflowArgsV2 args = new()
  {
      UserId = request.UserId,
  };

  WorkflowHandle<UserGrantedWorkflowV2> handle = await _temporalClient
      .StartWorkflowAsync<UserGrantedWorkflowV2>(x => x.Run(args), options);

  return Json(new StartWorkflowResponse
  {
      Id = handle.Id,
      RunId = handle.RunId,
  });

  static string BuildId(string userId)
  {
      return $"UserGranted.{userId}";
  }
}
```

</details>

### Workflow versioning: workflow task queue versioning

### Workflow versioning: patched api

### Workflow versioning: worker versioning

## Workflow versioning: нюансы интеграций

Как я выше писал, версионирование самих workflow - это только одна из проблем.
Помимо версионирования самих workflow, довольно часто приходится сталкиваться с тем, что изменение workflow и их миграция занимает какое-то время, из-за чего так же приходится версионировать и обычные сервисы, сохраняя в них старое и новое поведение.

Это приводит к тому, что workflow должны иметь возможность вызывать разные ручки в системах (v1, v2, etc) или же системы должны иметь возможность запускать разные версии workflow (или даже одни и те же версии, но с дополнительными метаданными, которые будут влиять на логику обработки внутри workflow)

В особо сложных сценариях подобные требования приводят к тому, что все места интеграции и на уровне workflow, и на уровне систем (сервисов) каскадно обрастают множеством feature-flags, что может довольно сильно замедлить разработку в целом. Увы, но это цена, которую мы вынуждены платить за zero-downtime продакшн и отсутствие седых волос на голове всех инженеров.

Рассмотрим один из таких сценариев на реальном примере. Допустим, у нас есть процесс обработки заказа, который в верхнеуровнево выглядит так

1. Запрос приходит в модуль ordering, который вызывает ряд других модулей для получения различных данных и дальнейшего in-memory расчета различных атрибутов заказа (например, стоимости)
2. Заказ сохраняется в базу данных, а в таблицу outbox помещается запись о том, что заказ был создан
3. Воркер вычитывает запись из таблицы outbox и запускает order processing workflow в temporal

Поступает продуктовое требование запустить эксперимент, который
