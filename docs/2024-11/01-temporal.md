- #orchestration
- #distributed_transactions
- #temporal

Часть 1:

В сегодняшнем посте речь пойдет о temporal и о том, как мы его готовим. Для тех, кто не в курсе, temporal - движок оркестрации процессов, который ставится отдельным инфраструктурным компонентом в кластер и может выступать в качестве платформы для реализации долгоиграющих процессов. 

Естественно, всякие ништяки, вроде персистентности шагов, DR, довольно шустрого исполнения и прочего - в наличии. Почитать можно тут https://temporal.io/

Сам темпорал состоит из нескольких ключевых компонентов, а именно
- кластера - платформы, которая умеет планировать задачи, выполнять их, регистрировать воркеры и тд
- воркеров - отдельных приложений, которые хостят и запускают реализованные инженерами процессы (в дальнейшем - воркфлоу)

Каждый воркер может содержать несколько воркфлоу. Их можно запускать в разных очередях задач и неймспейсах. Подробнее с этими концепциями можно ознакомиться, опять же, в документации 

Важно понимать следующее: все шаги темпорал персистит в БД, и когда он восстанавливает воркфлоу, он заново проходит по всем шагам от начала и до конца (конец - место последней остановки / ожидания следующего шага).

Проблема здесь кроется в non-deterministic апдейтах. Что это значит: была у вас последовательность шагов S1 -> S2 -> S3. Допустим, вам потребовалось изменить эту последовательность. Например, добавив ожидание перед S3 или какой-то дополнительный шаг, вроде S2.1, который запускается для каких-то специфических кейсов


```cs
S2();
if(User.Age >= 18)
{
   S2.1()
}
```


В таком случае, если темпорал уже выполнил S2 и приступил к выполнению S3, то в момент перезагрузки он попытается восстановить историю и увидит, что там, где он в БД ожидал увидеть сохраненный стейт для S3, он встречает шаг S2.1. В этом случае он не будет знать, что ему делать и просто встанет колом, начав кричать о том, что он не может продолжить выполнение. 

Очевидно, что такое поведение недопустимо, поскольку нам нужно уметь редактировать процессы и вносить в них изменения. Соответственно, нужно найти способ версионирования наших процессов. Об этом чуть позже.

Вторая проблема (на самом деле, это не совсем проблема, скорее не очень приятная особенность) заключается в необходимости протаскивать temporal sdk в конкретные приложения для того, чтобы уметь запускать воркфлоу или посылать в работающие воркфлоу сигналы, запрашивать апдейты и тд. 

Это приводит к тому, что в приложения просачивается информация о temporal и его инфраструктуре, а также специфическом api 
в приложениях появляется довольно большая портянка из конфигов для различных воркфлоу, информация о неймспейсах и очередях задач. это довольно непросто поддерживать, да и это весьма сильно увеличивает общую хрупкость системы.  каждый раз приходится писать код, который будет гарантировать идемпотентный запуск воркфлоу, выполняя проверки наличия уже запущенных процессов

Чтобы избежать подобных проблем, мы выработали несколько подходов, которые позволяют существенно упростить интеграцию temporal workflows в существующую инфраструктуру, а также упростить миграции существующих процессов. 

Прежде всего, начать хочется с ограждения всей операционной нагрузки от знаний о темпорал. Чтобы этого достичь, мы решили прятать temporal sdk за полноценным ASP .NET Core приложением. 

То есть в нашей системе мы создаем полноценное .net приложение, в котором через DI механизм подключается temporal client и регистрируется набор activity & workflows. Все знания об очередях, неймспейсах, воркфлоу и их версиях остаются исключительно в рамках этого сервиса, и для всех внешних сервисов взаимодействие с ним ничем не отличается от взаимодействия с любым другим набором систем. 

В таком приложении мы описываем контроллеры, следуя нашим внутренним гайдлайнам разработки http api, валидаторы запросов, подключаем jwt и авторизацию, метрики и хелсчеки.. За версионирование (об этом чуть подробнее позже) та же отвечает этот же сервис, где в коде контроллера инженер может принять решение о вызове той или иной версии.

Внешним системам не нужно знать ни о концепции сигналов, ни о типах воркфлоу, ни об очередях, как я писал выше. Это просто вызов ручки с нужными пермишнами. Идемпотентность (если она нужна) так же может определяться внутри методов контроллера. Вот пример кода с реального продакшна


```cs
[HttpPost(“system.clients.startUserGrantedWorkflow”)]
public async Task<IActionResult> StartUserGrantedWorkflow([FromBody] StartUserGrantedWorkflowRequest request)
{
    string workflowId = BuildId(request.UserId);

    WorkflowHandle existingHandle =
        _temporalClient.GetWorkflowHandle(workflowId);
    WorkflowExecutionDescription workflowDescription = default;

    try
    {
        workflowDescription = await existingHandle.DescribeAsync();
    }
    catch (TemporalException ex)
        when (ex is RpcException { Code: RpcException.StatusCode.NotFound })
    {
        _logger.LogInformation("Workflow '{id}' was not found", workflowId);
    }

    if (workflowDescription != null)
    {
        _logger.LogInformation("Workflow '{id}' already exists, skip ({details})", workflowId, new
        {
            id = workflowDescription.Id,
            status = workflowDescription.Status,
            runId = workflowDescription.RunId,
        });

        return Json(new StartWorkflowResponse
        {
            Id = workflowDescription.Id,
            RunId = workflowDescription.RunId,
        });
    }

    WorkflowOptions options = new()
    {
        Id = workflowId,
        RequestEagerStart = true,
        TaskQueue = TemporalTaskQueues.Clients
    };

    UserGrantedWorkflowArgs args = new()
    {
        UserId = request.UserId,
    };

    WorkflowHandle<UserGrantedWorkflow> handle = await _temporalClient
        .StartWorkflowAsync<UserGrantedWorkflow>(x => x.Run(args), options);

    return Json(new StartWorkflowResponse
    {
        Id = handle.Id,
        RunId = handle.RunId,
    });

    static string BuildId(string userId)
    {
        return $"UserGranted.{userId}";
    }
}
```


Часть деталей здесь упущена, но смысл понятен: в данном случае за простой веб-апишкой скрывается идемпотентный запуск процесса грантования пользователя (рассылки нужных пуш-уведомлений и предоставления ряда скидок). Запускается такой процесс весьма тривиально: из outbox воркера другого приложения. Как видим, взаимодействие происходит через ITemporalClient, который инжектируется через стандартный DI в конструктор контроллера


private readonly ILogger _logger;
    private readonly ITemporalClient _temporalClient;

    public ClientsController(
        ILogger<ClientsController> logger,
        ITemporalClient temporalClient)
    {
        _logger = logger;
        _temporalClient = temporalClient;
    }


Чуть позже мы рассмотрим, как воркфлоу регистрируются и интегрируются в хост ASP .NET Core приложений

 