- <b style="color: blue">#temporal</b>
- <b style="color: blue">#distributed_transactions</b>
- <b style="color: blue">#orchestration</b>

# Temporal: Введение. Часть 1

В сегодняшнем посте речь пойдет о `Temporal` и о том, как мы его используем. Для тех, кто не в курсе, `Temporal` — движок оркестрации процессов, который устанавливается как отдельный инфраструктурный компонент в кластер и может выступать в качестве платформы для реализации длительных процессов.

Естественно, такие преимущества, как персистентность шагов, восстановление после сбоев (DR), высокая скорость исполнения и прочее — все это присутствует. Почитать можно [здесь](https://temporal.io/).

Сам Temporal состоит из нескольких ключевых компонентов:

- **Кластер** — платформа, которая умеет планировать задачи, выполнять их, регистрировать воркеры и т.д.
- **Воркеры** — отдельные приложения, которые хостят и запускают реализованные инженерами процессы (в дальнейшем — воркфлоу).

Каждый воркер может содержать несколько воркфлоу. Их можно запускать в разных очередях задач и неймспейсах. Подробнее с этими концепциями можно ознакомиться в документации.

Важно понимать следующее: все шаги `Temporal` персистит в базе данных, и когда он восстанавливает воркфлоу, он заново проходит по всем шагам от начала и до конца (до места последней остановки или ожидания следующего шага).

## Проблемы и нюансы, которые будут вас ждать

Как и у любой технологии, у `Temporal` есть ряд особенностей, о которых стоит знать прежде, чем вы столкнетесь (жаль, что нам не объяснили, ха-ха ;) )

Давайте обсудим некоторые из них подробнее

### Проблема с недетерминированными обновлениями

Проблема здесь кроется в **недетерминированных обновлениях**. Что это значит: была у вас последовательность шагов `S1 -> S2 -> S3`. Допустим, вам потребовалось изменить эту последовательность, например, добавив ожидание перед `S3` или какой-то дополнительный шаг, вроде `S2.1`, который запускается для специфических кейсов:

```csharp
S2();
if (User.Age >= 18)
{
    S2_1();
}
```

В таком случае, если `Temporal` уже выполнил `S2` и приступил к выполнению `S3`, то в момент перезагрузки он попытается восстановить историю и увидит, что там, где он в базе данных ожидал увидеть сохраненное состояние для `S3`, он встречает шаг `S2_1`. В этом случае он не будет знать, что делать, и просто остановится, начав сигнализировать о том, что не может продолжить выполнение.

Очевидно, что такое поведение недопустимо, поскольку нам нужно уметь редактировать процессы и вносить в них изменения. Соответственно, нужно найти способ версионирования наших процессов. Об этом поговорим чуть позже.

### Проблема с внедрением Temporal SDK

Вторая проблема (на самом деле, это не совсем проблема, скорее неприятная особенность) заключается в необходимости протаскивать `Temporal SDK` в конкретные приложения для того, чтобы уметь запускать воркфлоу или посылать в работающие воркфлоу сигналы, запрашивать обновления и т.д.

Это приводит к тому, что в приложения проникает информация о `Temporal` и его инфраструктуре, а также специфическое API. В приложениях появляется довольно большой объем конфигураций для различных воркфлоу, информация о неймспейсах и очередях задач. Это довольно непросто поддерживать и существенно увеличивает общую хрупкость системы. Каждый раз приходится писать код, который будет гарантировать идемпотентный запуск воркфлоу, выполняя проверки наличия уже запущенных процессов.

## Наши подходы к интеграции Temporal

Чтобы избежать подобных проблем, мы выработали несколько подходов, которые позволяют существенно упростить интеграцию `Temporal` workflows в существующую инфраструктуру, а также упростить миграции существующих процессов.

### Ограждение операционной нагрузки от знаний о Temporal

Прежде всего, мы решили оградить всю операционную нагрузку от знаний о `Temporal`. Чтобы этого достичь, мы спрятали `Temporal SDK` за полноценным `ASP.NET Core` приложением.

То есть в нашей системе мы создаем полноценное .NET-приложение, в котором через механизм Dependency Injection (DI) подключается `Temporal Client` и регистрируется набор `Activity` и `Workflows`. Все знания об очередях, неймспейсах, воркфлоу и их версиях остаются исключительно в рамках этого сервиса, и для всех внешних сервисов взаимодействие с ним ничем не отличается от взаимодействия с любым другим набором систем.

В таком приложении мы описываем контроллеры, следуя нашим внутренним гайдлайнам разработки HTTP API, валидаторы запросов, подключаем JWT и авторизацию, метрики и health checks. За версионирование (об этом чуть подробнее позже) также отвечает этот же сервис, где в коде контроллера инженер может принять решение о вызове той или иной версии.

Внешним системам не нужно знать ни о концепции сигналов, ни о типах воркфлоу, ни об очередях, как было описано выше. Это просто вызов эндпоинта с нужными правами доступа. Идемпотентность (если она нужна) также может определяться внутри методов контроллера.

### Пример реализации

Вот пример кода с реального продакшена:

```cs
[HttpPost("system.clients.startUserGrantedWorkflow")]
public async Task<IActionResult> StartUserGrantedWorkflow([FromBody] StartUserGrantedWorkflowRequest request)
{
    string workflowId = BuildId(request.UserId);

    WorkflowHandle existingHandle = _temporalClient.GetWorkflowHandle(workflowId);
    WorkflowExecutionDescription workflowDescription = default;

    try
    {
        workflowDescription = await existingHandle.DescribeAsync();
    }
    catch (TemporalException ex) when (ex is RpcException { Code: RpcException.StatusCode.NotFound })
    {
        _logger.LogInformation("Workflow '{id}' was not found", workflowId);
    }

    if (workflowDescription != null)
    {
        _logger.LogInformation("Workflow '{id}' already exists, skip ({details})", workflowId, new
        {
            id = workflowDescription.Id,
            status = workflowDescription.Status,
            runId = workflowDescription.RunId,
        });

        return Json(new StartWorkflowResponse
        {
            Id = workflowDescription.Id,
            RunId = workflowDescription.RunId,
        });
    }

    WorkflowOptions options = new()
    {
        Id = workflowId,
        RequestEagerStart = true,
        TaskQueue = TemporalTaskQueues.Clients
    };

    UserGrantedWorkflowArgs args = new()
    {
        UserId = request.UserId,
    };

    WorkflowHandle<UserGrantedWorkflow> handle = await _temporalClient
        .StartWorkflowAsync<UserGrantedWorkflow>(x => x.Run(args), options);

    return Json(new StartWorkflowResponse
    {
        Id = handle.Id,
        RunId = handle.RunId,
    });

    static string BuildId(string userId)
    {
        return $"UserGranted.{userId}";
    }
}
```

Часть деталей здесь упущена, но смысл понятен: в данном случае за простой веб-API скрывается идемпотентный запуск процесса предоставления пользователю определенных привилегий (рассылка нужных push-уведомлений и предоставление ряда скидок). Запускается такой процесс весьма тривиально: из outbox-воркера другого приложения.

Как видим, взаимодействие происходит через `ITemporalClient`, который инжектируется через стандартный DI в конструктор контроллера:

```cs
private readonly ILogger _logger;
private readonly ITemporalClient _temporalClient;

public ClientsController(
    ILogger<ClientsController> logger,
    ITemporalClient temporalClient)
{
    _logger = logger;
    _temporalClient = temporalClient;
}
```

Чуть позже мы рассмотрим, как воркфлоу регистрируются и интегрируются в хост `ASP.NET Core` приложений.
