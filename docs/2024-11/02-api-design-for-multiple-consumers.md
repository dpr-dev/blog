- #api_design
- #temporal
- #system_design

Часть 1.1: ответвление про api

Продолжая цикл статей о temporal, решил отвлечься на другую тему, которая мало к нему относится: дизайн апи.

Мне задали несколько вопросов о том, что за непонятное название урла в атрибуте встретилось в предыдущей статье ([HttpPost(“system.clients.startUserGrantedWorkflow”)]). Вопрос был вызван наличием группы system в адресе ручки контроллера

Решил немного пролить свет на эту тему и описать, зачем мы составляем урлы такого вида, чем это обусловлено и какие последствия это дает на весь проект. 

Начать хочется с вопроса, который звучит так: "а зачем вообще мы разрабатываем api ?". 
С одной стороны, вопрос довольно очевидный, с другой - важный, поскольку нужно довольно четко понимать, что, разрабатывая апи, мы стремимся предоставить потребителю апи всю необходимую информацию со стороны нашей ИС для того, чтобы этот потребитель апи мог эффективно и быстро реализовать нужную интеграцию.

Потребителей апи можно кластеризовать по довольно большому количеству критериев, например
- вид приложения / клиента (которые, в том числе, могут иметь довольно специфические требования к среде запуска. например, не иметь каких-либо компонентов, вроде браузеров)
- вид отношений относительно к компании / департаменту / продукту (публичное апи для партнеров, self hosted версии продукта, внутренний апи для кросс-мандных интеграций, или публичный апи группы систем для кросс-департаментных интеграций)
- тип услуг, который предоставляется через апи (например, платная / бесплатная версия продукта)
- частотности изменения и скорости адаптации
- много чего ещё

Проблема здесь заключается в том, что разные потребители могут выставлять довольно большое количество различных требований, которые могут оказывать довольно сильное влияние на архитектуру решения

К таким требованиям можно отнести требования к
- производительности
- аутентификации и авторизации (особенно, если речь идет о browserless средах)
- безопасности (данные, различные контура и др.)
- типу данных
- политики версионирования и поддержки, миграции, SLA, etc

Довольно часто бывает так, что многие не особо об этом задумываются, из-за чего одну и ту же ручку для получения каких-либо данных (или совершения какого-либо действия) просто переиспользуют и делают доступной для разных типов потребителей апи. 

К чему это может привести ? Если продукт не очень большой или не очень сложный, то, возможно, проблемы в моменте / short / mid-term и не проявят себя. 
В противном случае, мы получим систему, изменения в которой могут оказывать непредсказуемое и разрушающее влияние на различные её компоненты (или даже на внешние системы, которые с ней интегрируются).

Я видел, как апи для внутренних клиентских (customer) UI приложений (веб, мобильных) переиспользовалось и для веб приложений отдела операций, и внутренних систем. 
Приводило это к тому, что 
- на одну ручку навешивалось довольно большое количество политик авторизации, которые довольно сильно усложняли поддержку и тестирование
- различные системы получали разный объем данных, в т.ч. те данные, которые им были не нужны (что, например, вызывало определенные консерны со стороны отделов ИБ)
- из-за растущего каплинга (в т.ч. из-за предыдущего пункта), изменения апи по запросу конкретного потребителя приводили к тому, что ломались другие потребители, из-за чего поднимался вопрос их не запланированной миграции и дополнительной траты времени и ресурсов разработки / тестирования. это может не быть серьезной проблемой, если у вас есть несколько небольших приложений, которые имеют довольно высокую скорость внедрения изменений, но может стать существенной проблемой, если частотность релизов разная и скорость выпуска обновлений различается (например, веб и мобильные приложения имеют довольно разные ограничения: для мобильных приложений необходимо проходить процесс ревью в магазинах, что довольно легко может накидывать несколько дней и блочить релиз для другой части системы. Ну а если речь идет о партнерах в других департаментах или компаниях, то мы вообще можем говорить о месяцах).
- все из-за того же каплинга повышается хрупкость системы, когда даже довольно небольшое изменение может просто убить часть потребителей апи

Решая задачу управления сложностью изменений (и их предсказуемостью), очевидно, мы хотим защититься от подобных проблем. 
именно поэтому стоит довольно хорошо подумать, кто и как будет использовать ваше апи, чтобы выделить различные группы потребителей. Для каждой такой группы стоит разрабатывать и поддерживать свой набор апи эндпоинтов, устройство и организация которых может быть довольно разной. 

У нас, например, выделено 3 типа консьюмеров
- публичные (которые уходят в общедоступный интернет и используются мобильными приложениями клиентов)
- внутренние (которые используются только для реализации внутренних систем, вроде различных админок для сотрудников из бизнес юнитов маркетинга и операций)
- системные (которые используются только для межсистемных интеграций)

Как всегда, у такого решения есть свой набор трейдоффов, с которыми, скорее всего, просто необходимо будет смириться

Например, с точки зрения разработки, для каждой ручки из разных групп довольно часто придется дублировать контракты. Если клиенту, опсам в админке и внутренним системам нужно получать информацию о заказе по его id, то нужно будет задизайнить 3 отдельные ручки с 3мя разными контрактами заказа. Например
- `public.orders.getById` - `ClientOrderViewDto`
- `internal.orders.getById` - `InternalOrderViewDto`
- `system.orders.getById` - `SystemOrderViewDto`

Это делается для того, чтобы изменения контракта по требованию одного консьюмера (потребителя) не повлияли на других консьюмеров. Поэтому переиспользование лучше свести до минимума. Исключение - некоторые неизменные структуры данных, возможно, вроде валют, перечислений (enum), адресов и др

Обратите внимание, что у каждой ручки, скорее всего, будут свои политики авторизации, а так же будет возвращаться свой набор данных. 

Так, например, для публичной ручки (которую использует клиент) политика будет довольно простой
- актор имеет роль client
- айди клиента в заказе равен клейму актора (sub, nameidentifier)

Для опсовой (internal) ручки, которая получает заказ для отображения в админке, набор данных может быть сильно ограничен (например, вырезаны некоторые ПД), а политика может быть существенно сложнее
- актор имеет роль ops-admin или набор скоупов `orders.get`, `orders.manage`
- актор назначен на заказ как лицо, которое хочет решить проблему (вопрос) конкретного клиента по конкретному заказу
- назначение активно (не закрыто / доступно в течение 30 мин после назначения и тд)

Для системной ручки все может ограничится только проверкой скоупа апишки, например, и клейма `client_type = machine`
—

Как мы можем заметить, даже на таком небольшом примере довольно сильно видны различия в подходах и требованиях. Можно представить, сколько проблем добавит поддержка подобных правил, если не прибегать к разграничению апи для различных потребителей. 

Ну а выводы, как и анализ применимости подобных подходов, пусть каждый сделает сам