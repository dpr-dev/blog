- <b style="color: blue">#api_design</b>
- <b style="color: blue">#system_design</b>

# Дизайн API: Как быть, когда есть множество потребителей

Хотя я начал писать о Temporal, решил отвлечься на другую тему, которая с ним мало связана: дизайн API.

В предыдущей статье о [Temporal](/docs/2024-11/01-temporal-intro-part-1.md) мне задали несколько вопросов о непонятном атрибуте в названии URL, который встретился в тексте прошлой статьи: [HttpPost("system.clients.startUserGrantedWorkflow")]. Вопрос был вызван наличием группы system в URL адресе.

Решил пролить свет на эту тему и описать, зачем мы составляем URL-адреса такого вида, чем это обусловлено и какие последствия это может иметь для всего проекта.

## Зачем мы разрабатываем API?

С одной стороны, вопрос довольно очевидный, с другой — важный, поскольку нужно четко понимать, что, разрабатывая API, мы стремимся предоставить потребителю всю необходимую информацию со стороны нашей информационной системы, чтобы этот потребитель мог эффективно и быстро реализовать нужную интеграцию.

## Типы потребителей API и их классификация

Сразу возникает вопрос: **а какие вообще могут быть потребители API, и можем ли мы их как-то классифицировать**? Ответ простой: да, можем. Потребителей API можно классифицировать по большому количеству критериев, например:

- **Вид приложения/клиента:** могут иметь специфические требования к среде запуска (например, отсутствие браузера).
- **Тип отношений к компании/департаменту/продукту:** публичное API для партнеров, self-hosted версии продукта, внутреннее API для кросс-командных интеграций или публичное API группы систем для кросс-департаментных интеграций.
- **Тип услуг, предоставляемых через API:** например, платная или бесплатная версия продукта.
- **Частотность изменений и скорость адаптации.**
- **Множество других критериев.**

### Влияние требований потребителей на архитектуру

Проблема заключается в том, что разные потребители могут выставлять большое количество различных требований, которые могут оказывать сильное влияние на архитектуру решения. К таким требованиям можно отнести:

- **Производительность.**
- **Аутентификация и авторизация** (особенно в средах без браузера).
- **Безопасность** (данные, различные контуры и другие аспекты).
- **Типы данных.**
- **Политики версионирования и поддержки**, миграции, SLA и т.д.

Довольно часто бывает так, что многие не задумываются об этом, из-за чего одну и ту же ручку для получения каких-либо данных или совершения действия просто переиспользуют и делают доступной для разных типов потребителей API.

## Возможные проблемы при переиспользовании API

Если продукт не очень большой или сложный, то, возможно, проблемы в краткосрочной или среднесрочной перспективе не проявят себя. В противном случае мы можем получить систему, изменения в которой могут оказывать непредсказуемое и разрушающее влияние на различные ее компоненты или даже на внешние системы, которые с ней интегрируются.

Я видел, как API для внутренних клиентских (customer) UI-приложений (веб, мобильных) переиспользовался и для веб-приложений отдела операций и внутренних систем. Это приводило к следующим проблемам:

- **Сложные политики авторизации:** На одну ручку навешивалось большое количество политик авторизации, которые сильно усложняли поддержку и тестирование.
- **Избыточность данных:** Различные системы получали разный объем данных, в том числе те, которые им были не нужны (что вызывало определенные опасения со стороны отделов информационной безопасности).
- **Разрушение других потребителей при изменениях:** Из-за растущей связности (каплинга) изменения API по запросу конкретного потребителя приводили к тому, что ломались другие потребители. Это вызывало необходимость их незапланированной миграции и дополнительных затрат времени и ресурсов на разработку и тестирование. Это может стать существенной проблемой, если частотность релизов разная и скорость выпуска обновлений отличается (например, мобильные приложения требуют прохождения ревью в магазинах).
- **Повышенная хрупкость системы:** Даже небольшое изменение могло нарушить работу части потребителей API.

## Решение: Разграничение API для различных потребителей

Решая задачу управления сложностью изменений (и их предсказуемостью), мы хотим защититься от подобных проблем. Именно поэтому стоит хорошо продумать, кто и как будет использовать ваше API, чтобы выделить различные группы потребителей. Для каждой такой группы стоит разрабатывать и поддерживать свой набор API-эндпоинтов, устройство и организация которых могут быть разными.

У нас, например, выделено три типа потребителей:

- **Публичные:** уходят в общедоступный интернет и используются мобильными приложениями клиентов.
- **Внутренние:** используются только для реализации внутренних систем, таких как админки для сотрудников из бизнес-юнитов маркетинга и операций.
- **Системные:** используются только для межсистемных интеграций.

Например, вместо того, чтобы создавать одну ручку, вроде `orders.getById`, мы создаем 3 отдельные:

- `public.orders.getById` — возвращает `ClientOrderViewDto`.
- `internal.orders.getById` — возвращает `InternalOrderViewDto`.
- `system.orders.getById` — возвращает `SystemOrderViewDto`.

Обратите внимание, что у каждой ручки, скорее всего, будут свои политики авторизации, а также будет возвращаться свой набор данных.

- **Публичная ручка:**
  - Актор имеет роль client.
  - ID клиента в заказе равен claim актора (sub, nameidentifier).
- **Внутренняя (internal) ручка:**
  - Актор имеет роль ops-admin или набор скоупов orders.get, orders.manage.
  - Актор назначен на заказ как лицо, которое решает проблему конкретного клиента.
  - Назначение активно (не закрыто, доступно в течение 30 минут после назначения и т.д.).
- **Системная ручка:**
  - Проверка скоупа API.
  - Claim client_type = machine.

### Компромиссы и трейд-оффы

Как всегда, у такого решения есть свой набор компромиссов, с которыми, скорее всего, необходимо будет смириться.

С точки зрения разработки, для каждой ручки из разных групп довольно часто придется дублировать контракты. Если клиенту, операторам в админке и внутренним системам нужно получать информацию о заказе по его ID, то нужно будет разработать три отдельные ручки с тремя разными контрактами заказа. Это делается для того, чтобы изменения контракта по требованию одного потребителя не повлияли на других. Поэтому переиспользование лучше свести к минимуму. Исключение — некоторые неизменные структуры данных, такие как валюты, перечисления (enum), адреса и другие.

## Заключение

Как мы можем заметить, даже на таком небольшом примере видны существенные различия в подходах и требованиях. Можно представить, сколько проблем добавит поддержка подобных правил, если не прибегать к разграничению API для различных потребителей.

Выводы:

- **Четкое определение групп потребителей API** и разработка для каждой из них отдельного набора эндпоинтов помогает избежать множества проблем.
- **Дополнительные усилия** на этапе разработки и поддержки окупаются в долгосрочной перспективе за счет снижения рисков, связанных с каплингом, нарушением безопасности и сложностью тестирования.
- **Анализ применимости таких подходов** в вашем проекте остается за вами.

---

**Примечание:** Подобный подход требует тщательного планирования и понимания специфики вашего проекта. Возможно, стоит провести дополнительный анализ и обсудить с командой, как лучше организовать API в вашем случае.
